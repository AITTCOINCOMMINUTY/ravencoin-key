{"mappings":";;;;;;AAAA,uCAAuC;;;;;;;AAiBvC,SAAS,iCAAW,IAAa;IAC/B,MAAM,IAAI,KAAK,WAAW,IAAI,iBAAiB;IAC/C,MAAM,MAAM;QACV,MAAM,CAAA,GAAA,aAAK,EAAE,IAAI,CAAC,OAAO,CAAC,QAAQ;IACpC;IAEA,MAAM,UAAU,GAAG,CAAC,EAAE;IACtB,IAAI,CAAC,SACH,MAAM,IAAI,MAAM,8BAA8B,OAAO,IAAI,CAAC,KAAK,QAAQ;IAEzE,OAAO;AACT;AAMO,SAAS,0CAAY,OAAgB;IAC1C,MAAM,QAAQ,iCAAW;IACzB,OAAO,MAAM,KAAK;AACpB;AAOO,SAAS,0CACd,OAAgB,EAChB,QAAgB,EAChB,OAAe,EACf,QAAgB;IAEhB,MAAM,QAAQ,0CAAS,SAAS;IAChC,MAAM,YAAY,0CAAY;IAE9B,+DAA+D;IAE/D,iBAAiB;IACjB,+DAA+D;IAC/D,MAAM,eAAe,CAAC,MAAM,EAAE,UAAU,EAAE,EAAE,QAAQ,IAAI,EAAE,SAAS,CAAC;IACpE,MAAM,kBAAkB,0CAAiB,SAAS,OAAO;IAEzD,gBAAgB;IAChB,MAAM,eAAe,CAAC,MAAM,EAAE,UAAU,EAAE,EAAE,QAAQ,IAAI,EAAE,SAAS,CAAC;IACpE,MAAM,kBAAkB,0CAAiB,SAAS,OAAO;IACzD,OAAO;QACL,UAAU;QACV,UAAU;kBACV;IACF;AACF;AAEO,SAAS,0CAAS,OAAgB,EAAE,QAAgB;IACzD,MAAM,QAAQ,iCAAW;IACzB,MAAM,OAAO,0BAAyB,UAAU,QAAQ,CAAC;IACzD,yDAAyD;IACzD,MAAM,QAAQ,sBAAqB,iCAAO,IAAI,CAAC,MAAM,QAAQ,MAAM,KAAK;IACxE,OAAO;AACT;AAEO,SAAS,0CACd,OAAgB,EAChB,KAAU,EACV,IAAY;IAEZ,MAAM,QAAQ,iCAAW;IACzB,MAAM,UAAU,MAAM,MAAM,CAAC;IAC7B,IAAI,MAAM,IAAI,eAAQ,QAAQ,UAAU,EAAE;IAE1C,OAAO;QACL,SAAS,IAAI,aAAa;QAC1B,MAAM;QACN,YAAY,IAAI,UAAU,CAAC,QAAQ,CAAC;QACpC,KAAK,IAAI,UAAU;IACrB;AACF;AAEO,SAAS;IACd,OAAO;AACT;AAEO,SAAS,0CAAgB,QAAgB;IAC9C,qBAAqB;IACrB,MAAM,YAAY,OAAO,MAAM,CAAC;IAEhC,oEAAoE;IACpE,KAAK,MAAM,YAAY,UAAW;QAChC,MAAM,IAAI,wBAAuB,UAAU;QAC3C,IAAI,MAAM,MACR,OAAO;IAEX;IACA,OAAO;AACT;AAQO,SAAS,0CAAgB,OAAgB,EAAE,aAAqB;IACrE,MAAM,UAAU,eAAQ,OAAO,CAAC;IAChC,QAAQ,QAAQ,GAAG,iCAAW;IAE9B,OAAO;QACL,SAAS,QAAQ,aAAa;QAC9B,YAAY,QAAQ,UAAU,CAAC,QAAQ,CAAC;QACxC,KAAK,QAAQ,UAAU;IACzB;AACF;AAEO,MAAM,4CAAoB;AAE1B,SAAS,0CACd,UAAmB,MAAM;IAEzB,MAAM,WAAW;IACjB,MAAM,UAAU;IAChB,MAAM,WAAW;IACjB,MAAM,cAAc,0CAAe,SAAS,UAAU,SAAS;IAC/D,MAAM,gBAAgB,YAAY,QAAQ;IAE1C,MAAM,SAAS;QACb,GAAG,aAAa;kBAChB;iBACA;IACF;IACA,OAAO;AACT;AASO,SAAS,0CAAgB,UAAmB,MAAM;IACvD,OAAO,0CAAsB;AAC/B;IACA,2CAAe;uBACb;qBACA;sBACA;sBACA;qBACA;oBACA;iBACA;cACA;qBACA;AACF","sources":["index.ts"],"sourcesContent":["//Gives us meta data about coins/chains\r\nimport { chains } from \"@hyperbitjs/chains\";\r\n\r\n//bip39 from mnemonic to seed\r\nimport * as bip39 from \"bip39\";\r\n\r\nconst CoinKey = require(\"coinkey\");\r\n\r\n//From seed to key\r\n//const HDKey = require(\"hdkey\");\r\nconst HDKey = require(\"hdkey\");\r\n// import * as HDKey from \"hdkey\";\r\nimport { IAddressObject } from \"./types\";\r\n\r\n//Could not declare Network as enum, something wrong with parcel bundler\r\nexport type Network = \"aitt\";\r\n\r\nfunction getNetwork(name: Network) {\r\n  const c = name.toLowerCase(); //Just to be sure\r\n  const map = {\r\n    aitt: chains.aitt.mainnet.versions,\r\n  };\r\n\r\n  const network = map[c];\r\n  if (!network) {\r\n    throw new Error(\"network must be of value \" + Object.keys(map).toString());\r\n  }\r\n  return network;\r\n}\r\n/**\r\n *\r\n * @param network\r\n * @returns the coin type for the network (blockchain), for example Ravencoin has coin type 175\r\n */\r\nexport function getCoinType(network: Network) {\r\n  const chain = getNetwork(network);\r\n  return chain.bip44;\r\n}\r\n/**\r\n * @param network - should have value \"rvn\", \"rvn-test\", \"evr\" or \"evr-test\"\r\n * @param mnemonic - your mnemonic\r\n * @param account - accounts in BIP44 starts from 0, 0 is the default account\r\n * @param position - starts from 0\r\n */\r\nexport function getAddressPair(\r\n  network: Network,\r\n  mnemonic: string,\r\n  account: number,\r\n  position: number\r\n) {\r\n  const hdKey = getHDKey(network, mnemonic);\r\n  const coin_type = getCoinType(network);\r\n\r\n  //https://github.com/satoshilabs/slips/blob/master/slip-0044.md\r\n\r\n  //Syntax of BIP44\r\n  //m / purpose' / coin_type' / account' / change / address_index\r\n  const externalPath = `m/44'/${coin_type}'/${account}'/0/${position}`;\r\n  const externalAddress = getAddressByPath(network, hdKey, externalPath);\r\n\r\n  //change address\r\n  const internalPath = `m/44'/${coin_type}'/${account}'/1/${position}`;\r\n  const internalAddress = getAddressByPath(network, hdKey, internalPath);\r\n  return {\r\n    internal: internalAddress,\r\n    external: externalAddress,\r\n    position,\r\n  };\r\n}\r\n\r\nexport function getHDKey(network: Network, mnemonic: string): any {\r\n  const chain = getNetwork(network);\r\n  const seed = bip39.mnemonicToSeedSync(mnemonic).toString(\"hex\");\r\n  //From the seed, get a hdKey, can we use CoinKey instead?\r\n  const hdKey = HDKey.fromMasterSeed(Buffer.from(seed, \"hex\"), chain.bip32);\r\n  return hdKey;\r\n}\r\n\r\nexport function getAddressByPath(\r\n  network: Network,\r\n  hdKey: any,\r\n  path: string\r\n): IAddressObject {\r\n  const chain = getNetwork(network);\r\n  const derived = hdKey.derive(path);\r\n  var ck2 = new CoinKey(derived.privateKey, chain);\r\n\r\n  return {\r\n    address: ck2.publicAddress,\r\n    path: path,\r\n    privateKey: ck2.privateKey.toString(\"hex\"),\r\n    WIF: ck2.privateWif,\r\n  };\r\n}\r\n\r\nexport function generateMnemonic() {\r\n  return bip39.generateMnemonic();\r\n}\r\n\r\nexport function isMnemonicValid(mnemonic: string) {\r\n  //Check all languages\r\n  const wordlists = Object.values(bip39.wordlists);\r\n\r\n  //If mnemonic is valid in any language, return true, otherwise false\r\n  for (const wordlist of wordlists) {\r\n    const v = bip39.validateMnemonic(mnemonic, wordlist);\r\n    if (v === true) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n/**\r\n *\r\n * @param privateKeyWIF\r\n * @param network  should be \"rvn\" or \"rvn-test\"\r\n * @returns object {address, privateKey (hex), WIF}\r\n */\r\n\r\nexport function getAddressByWIF(network: Network, privateKeyWIF: string) {\r\n  const coinKey = CoinKey.fromWif(privateKeyWIF);\r\n  coinKey.versions = getNetwork(network);\r\n\r\n  return {\r\n    address: coinKey.publicAddress,\r\n    privateKey: coinKey.privateKey.toString(\"hex\"),\r\n    WIF: coinKey.privateWif,\r\n  };\r\n}\r\n\r\nexport const entropyToMnemonic = bip39.entropyToMnemonic;\r\n\r\nexport function generateAddressObject(\r\n  network: Network = \"aitt\"\r\n): IAddressObject {\r\n  const mnemonic = generateMnemonic();\r\n  const account = 0;\r\n  const position = 0;\r\n  const addressPair = getAddressPair(network, mnemonic, account, position);\r\n  const addressObject = addressPair.external;\r\n\r\n  const result = {\r\n    ...addressObject,\r\n    mnemonic,\r\n    network,\r\n  };\r\n  return result;\r\n}\r\n\r\n/**\r\n * Generates a random Address Object\r\n *\r\n * @deprecated use generateAddressObject\r\n * @param network\r\n * @returns\r\n */\r\nexport function generateAddress(network: Network = \"aitt\") {\r\n  return generateAddressObject(network);\r\n}\r\nexport default {\r\n  entropyToMnemonic,\r\n  generateAddress,\r\n  generateMnemonic,\r\n  getAddressByPath,\r\n  getAddressByWIF,\r\n  getAddressPair,\r\n  getCoinType,\r\n  getHDKey,\r\n  isMnemonicValid,\r\n};\r\n"],"names":[],"version":3,"file":"module.js.map"}