{"mappings":";AAAA;IACE,OAAO,EAAE,MAAM,CAAC;IAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,IAAI,EAAE,MAAM,CAAC;IACb,UAAU,EAAE,MAAM,CAAC;IACnB,GAAG,EAAE,MAAM,CAAC;CACb;ACSD,sBAAsB,MAAM,CAAC;AAc7B;;;;GAIG;AACH,4BAA4B,OAAO,EAAE,OAAO,OAG3C;AACD;;;;;GAKG;AACH,+BACE,OAAO,EAAE,OAAO,EAChB,QAAQ,EAAE,MAAM,EAChB,OAAO,EAAE,MAAM,EACf,QAAQ,EAAE,MAAM;;;;EAoBjB;AAED,yBAAyB,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,GAAG,GAAG,CAMhE;AAED,iCACE,OAAO,EAAE,OAAO,EAChB,KAAK,EAAE,GAAG,EACV,IAAI,EAAE,MAAM,GACX,cAAc,CAWhB;AAED,2CAEC;AAED,gCAAgC,QAAQ,EAAE,MAAM,WAY/C;AACD;;;;;GAKG;AAEH,gCAAgC,OAAO,EAAE,OAAO,EAAE,aAAa,EAAE,MAAM;;;;EAStE;AAED,OAAO,MAAM,iDAA2C,CAAC;AAEzD,sCACE,OAAO,GAAE,OAAgB,GACxB,cAAc,CAahB;AAED;;;;;;GAMG;AACH,gCAAgC,OAAO,GAAE,OAAgB,kBAExD;;;;;;;;;;;;AACD,wBAUE","sources":["types.ts","index.ts"],"sourcesContent":["export interface IAddressObject {\r\n  address: string;\r\n  mnemonic?: string;\r\n  path: string;\r\n  privateKey: string;\r\n  WIF: string;\r\n}\r\n","//Gives us meta data about coins/chains\r\nimport { chains } from \"@hyperbitjs/chains\";\r\n\r\n//bip39 from mnemonic to seed\r\nimport * as bip39 from \"bip39\";\r\n\r\nconst CoinKey = require(\"coinkey\");\r\n\r\n//From seed to key\r\n//const HDKey = require(\"hdkey\");\r\nconst HDKey = require(\"hdkey\");\r\n// import * as HDKey from \"hdkey\";\r\nimport { IAddressObject } from \"./types\";\r\n\r\n//Could not declare Network as enum, something wrong with parcel bundler\r\nexport type Network = \"aitt\";\r\n\r\nfunction getNetwork(name: Network) {\r\n  const c = name.toLowerCase(); //Just to be sure\r\n  const map = {\r\n    aitt: chains.aitt.mainnet.versions,\r\n  };\r\n\r\n  const network = map[c];\r\n  if (!network) {\r\n    throw new Error(\"network must be of value \" + Object.keys(map).toString());\r\n  }\r\n  return network;\r\n}\r\n/**\r\n *\r\n * @param network\r\n * @returns the coin type for the network (blockchain), for example Ravencoin has coin type 175\r\n */\r\nexport function getCoinType(network: Network) {\r\n  const chain = getNetwork(network);\r\n  return chain.bip44;\r\n}\r\n/**\r\n * @param network - should have value \"rvn\", \"rvn-test\", \"evr\" or \"evr-test\"\r\n * @param mnemonic - your mnemonic\r\n * @param account - accounts in BIP44 starts from 0, 0 is the default account\r\n * @param position - starts from 0\r\n */\r\nexport function getAddressPair(\r\n  network: Network,\r\n  mnemonic: string,\r\n  account: number,\r\n  position: number\r\n) {\r\n  const hdKey = getHDKey(network, mnemonic);\r\n  const coin_type = getCoinType(network);\r\n\r\n  //https://github.com/satoshilabs/slips/blob/master/slip-0044.md\r\n\r\n  //Syntax of BIP44\r\n  //m / purpose' / coin_type' / account' / change / address_index\r\n  const externalPath = `m/44'/${coin_type}'/${account}'/0/${position}`;\r\n  const externalAddress = getAddressByPath(network, hdKey, externalPath);\r\n\r\n  //change address\r\n  const internalPath = `m/44'/${coin_type}'/${account}'/1/${position}`;\r\n  const internalAddress = getAddressByPath(network, hdKey, internalPath);\r\n  return {\r\n    internal: internalAddress,\r\n    external: externalAddress,\r\n    position,\r\n  };\r\n}\r\n\r\nexport function getHDKey(network: Network, mnemonic: string): any {\r\n  const chain = getNetwork(network);\r\n  const seed = bip39.mnemonicToSeedSync(mnemonic).toString(\"hex\");\r\n  //From the seed, get a hdKey, can we use CoinKey instead?\r\n  const hdKey = HDKey.fromMasterSeed(Buffer.from(seed, \"hex\"), chain.bip32);\r\n  return hdKey;\r\n}\r\n\r\nexport function getAddressByPath(\r\n  network: Network,\r\n  hdKey: any,\r\n  path: string\r\n): IAddressObject {\r\n  const chain = getNetwork(network);\r\n  const derived = hdKey.derive(path);\r\n  var ck2 = new CoinKey(derived.privateKey, chain);\r\n\r\n  return {\r\n    address: ck2.publicAddress,\r\n    path: path,\r\n    privateKey: ck2.privateKey.toString(\"hex\"),\r\n    WIF: ck2.privateWif,\r\n  };\r\n}\r\n\r\nexport function generateMnemonic() {\r\n  return bip39.generateMnemonic();\r\n}\r\n\r\nexport function isMnemonicValid(mnemonic: string) {\r\n  //Check all languages\r\n  const wordlists = Object.values(bip39.wordlists);\r\n\r\n  //If mnemonic is valid in any language, return true, otherwise false\r\n  for (const wordlist of wordlists) {\r\n    const v = bip39.validateMnemonic(mnemonic, wordlist);\r\n    if (v === true) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n/**\r\n *\r\n * @param privateKeyWIF\r\n * @param network  should be \"rvn\" or \"rvn-test\"\r\n * @returns object {address, privateKey (hex), WIF}\r\n */\r\n\r\nexport function getAddressByWIF(network: Network, privateKeyWIF: string) {\r\n  const coinKey = CoinKey.fromWif(privateKeyWIF);\r\n  coinKey.versions = getNetwork(network);\r\n\r\n  return {\r\n    address: coinKey.publicAddress,\r\n    privateKey: coinKey.privateKey.toString(\"hex\"),\r\n    WIF: coinKey.privateWif,\r\n  };\r\n}\r\n\r\nexport const entropyToMnemonic = bip39.entropyToMnemonic;\r\n\r\nexport function generateAddressObject(\r\n  network: Network = \"aitt\"\r\n): IAddressObject {\r\n  const mnemonic = generateMnemonic();\r\n  const account = 0;\r\n  const position = 0;\r\n  const addressPair = getAddressPair(network, mnemonic, account, position);\r\n  const addressObject = addressPair.external;\r\n\r\n  const result = {\r\n    ...addressObject,\r\n    mnemonic,\r\n    network,\r\n  };\r\n  return result;\r\n}\r\n\r\n/**\r\n * Generates a random Address Object\r\n *\r\n * @deprecated use generateAddressObject\r\n * @param network\r\n * @returns\r\n */\r\nexport function generateAddress(network: Network = \"aitt\") {\r\n  return generateAddressObject(network);\r\n}\r\nexport default {\r\n  entropyToMnemonic,\r\n  generateAddress,\r\n  generateMnemonic,\r\n  getAddressByPath,\r\n  getAddressByWIF,\r\n  getAddressPair,\r\n  getCoinType,\r\n  getHDKey,\r\n  isMnemonicValid,\r\n};\r\n"],"names":[],"version":3,"file":"types.d.ts.map"}